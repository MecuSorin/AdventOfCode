/* Author: Mecu Sorin       Phone: 0040747020102 */

package Day11

import "fmt"
import "strconv"
import "unicode/utf8"

var (
	constBytesA = []byte("a")[0]
	constBytesZ = []byte("z")[0]
	constBytes0 = []byte("0")[0]
	constBytes9 = []byte("9")[0]
)

type base26 int64

func (b base26) String() string {
	bAsString := strconv.FormatInt(int64(b), 26)
	result := ""
	for i, w := 0, 0; i < len(bAsString); i += w {
		rune, runeWidth := utf8.DecodeRuneInString(bAsString[i:])
		w = runeWidth

		adjustedRune, _ := adjustRune(rune)
		// Useless code because is called with a safe rune (generated by the strconv.FormatInt)
		// if nil != err {
		// 	return "", err
		// }
		result = result + adjustedRune
	}
	return result
}

func adjustRune(r rune) (string, error) {
	bytes := []byte(string([]rune{r}))
	// Useless code because is called with a safe rune (generated by the strconv.FormatInt)
	// if len(bytes) != 1 {
	// 	return "", fmt.Errorf("Invalid rune %c used for adjustment", r)
	// }
	current := bytes[0]
	if current <= constBytes9 {
		current = constBytesA + current - constBytes0
	} else {

		current += byte(10)
	}
	return string(current), nil
}

func getBase26FromString(representation string) (base26, error) {
	bytes := []byte(representation)
	resultBytes := make([]byte, len(bytes))
	for i := 0; i < len(resultBytes); i++ {
		current := bytes[i]

		if current < constBytesA || current > constBytesZ {
			return base26(-1), fmt.Errorf("Invalid password provided %q", representation)
		}
		if constBytesA+10 <= current {
			resultBytes[i] = current + (256 - 10)
		} else {
			resultBytes[i] = constBytes9 - (10 - (current - constBytesA)) + 1
		}
	}
	result, err := strconv.ParseInt(string(resultBytes), 26, 64)
	return base26(result), err
}
